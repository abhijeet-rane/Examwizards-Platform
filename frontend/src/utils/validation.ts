export interface ValidationRule {
  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  custom?: (value: any) => string | null;\n  message?: string;\n}\n\nexport interface ValidationRules {\n  [field: string]: ValidationRule;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string>;\n}\n\nexport class FormValidator {\n  /**\n   * Validate a single field\n   */\n  static validateField(value: any, rules: ValidationRule): string | null {\n    // Required validation\n    if (rules.required && (value === null || value === undefined || value === '')) {\n      return rules.message || 'This field is required';\n    }\n\n    // Skip other validations if field is empty and not required\n    if (!rules.required && (value === null || value === undefined || value === '')) {\n      return null;\n    }\n\n    const stringValue = String(value);\n\n    // Min length validation\n    if (rules.minLength && stringValue.length < rules.minLength) {\n      return rules.message || `Minimum length is ${rules.minLength} characters`;\n    }\n\n    // Max length validation\n    if (rules.maxLength && stringValue.length > rules.maxLength) {\n      return rules.message || `Maximum length is ${rules.maxLength} characters`;\n    }\n\n    // Pattern validation\n    if (rules.pattern && !rules.pattern.test(stringValue)) {\n      return rules.message || 'Invalid format';\n    }\n\n    // Custom validation\n    if (rules.custom) {\n      const customError = rules.custom(value);\n      if (customError) {\n        return customError;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validate multiple fields\n   */\n  static validateForm(data: Record<string, any>, rules: ValidationRules): ValidationResult {\n    const errors: Record<string, string> = {};\n\n    Object.entries(rules).forEach(([field, rule]) => {\n      const error = this.validateField(data[field], rule);\n      if (error) {\n        errors[field] = error;\n      }\n    });\n\n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Real-time field validation\n   */\n  static createFieldValidator(rules: ValidationRule) {\n    return (value: any): string | null => {\n      return this.validateField(value, rules);\n    };\n  }\n}\n\n// Common validation patterns\nexport const ValidationPatterns = {\n  email: /^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\\.[A-Za-z]{2,})$/,\n  phone: /^[+]?[1-9]?[0-9]{7,15}$/,\n  url: /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$/,\n  alphanumeric: /^[a-zA-Z0-9]+$/,\n  alphabetic: /^[a-zA-Z]+$/,\n  numeric: /^[0-9]+$/,\n  decimal: /^\\d+(\\.\\d{1,2})?$/,\n  strongPassword: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/\n};\n\n// Common validation rules\nexport const CommonValidationRules = {\n  required: { required: true },\n  \n  email: {\n    required: true,\n    pattern: ValidationPatterns.email,\n    message: 'Please enter a valid email address'\n  },\n  \n  password: {\n    required: true,\n    minLength: 8,\n    message: 'Password must be at least 8 characters long'\n  },\n  \n  strongPassword: {\n    required: true,\n    minLength: 8,\n    pattern: ValidationPatterns.strongPassword,\n    message: 'Password must contain at least 8 characters with uppercase, lowercase, number and special character'\n  },\n  \n  courseName: {\n    required: true,\n    minLength: 3,\n    maxLength: 100,\n    message: 'Course name must be between 3 and 100 characters'\n  },\n  \n  courseDescription: {\n    required: true,\n    minLength: 10,\n    maxLength: 1000,\n    message: 'Description must be between 10 and 1000 characters'\n  },\n  \n  price: {\n    required: true,\n    pattern: ValidationPatterns.decimal,\n    custom: (value: string) => {\n      const num = parseFloat(value);\n      if (isNaN(num) || num <= 0) {\n        return 'Price must be a positive number';\n      }\n      if (num > 100000) {\n        return 'Price cannot exceed ₹100,000';\n      }\n      return null;\n    }\n  },\n  \n  phone: {\n    pattern: ValidationPatterns.phone,\n    message: 'Please enter a valid phone number'\n  },\n  \n  url: {\n    pattern: ValidationPatterns.url,\n    message: 'Please enter a valid URL'\n  }\n};\n\n// Course-specific validation\nexport const CourseValidationRules = {\n  name: CommonValidationRules.courseName,\n  description: CommonValidationRules.courseDescription,\n  visibility: { required: true },\n  pricing: { required: true },\n  price: {\n    custom: (value: string, formData?: any) => {\n      if (formData?.pricing === 'PAID') {\n        if (!value || value.trim() === '') {\n          return 'Price is required for paid courses';\n        }\n        const num = parseFloat(value);\n        if (isNaN(num) || num <= 0) {\n          return 'Price must be a positive number';\n        }\n        if (num > 100000) {\n          return 'Price cannot exceed ₹100,000';\n        }\n      } else if (formData?.pricing === 'FREE' && value && parseFloat(value) > 0) {\n        return 'Free courses cannot have a price';\n      }\n      return null;\n    }\n  },\n  allowedEmails: {\n    custom: (value: string, formData?: any) => {\n      if (formData?.visibility === 'PRIVATE') {\n        if (!value || value.trim() === '') {\n          return 'Allowed emails are required for private courses';\n        }\n        const emails = value.split(',').map(email => email.trim());\n        for (const email of emails) {\n          if (!ValidationPatterns.email.test(email)) {\n            return `Invalid email format: ${email}`;\n          }\n        }\n      }\n      return null;\n    }\n  }\n};\n\n// Payment validation\nexport const PaymentValidationRules = {\n  razorpay_order_id: { required: true, message: 'Order ID is required' },\n  razorpay_payment_id: { required: true, message: 'Payment ID is required' },\n  razorpay_signature: { required: true, message: 'Payment signature is required' },\n  courseId: { \n    required: true, \n    custom: (value: any) => {\n      const num = parseInt(value);\n      if (isNaN(num) || num <= 0) {\n        return 'Invalid course ID';\n      }\n      return null;\n    }\n  }\n};\n\n// Enrollment validation\nexport const EnrollmentValidationRules = {\n  courseId: {\n    required: true,\n    custom: (value: any) => {\n      const num = parseInt(value);\n      if (isNaN(num) || num <= 0) {\n        return 'Invalid course ID';\n      }\n      return null;\n    }\n  }\n};\n\n// Utility functions\nexport const validateEmail = (email: string): boolean => {\n  return ValidationPatterns.email.test(email);\n};\n\nexport const validatePrice = (price: string): boolean => {\n  const num = parseFloat(price);\n  return !isNaN(num) && num > 0 && num <= 100000;\n};\n\nexport const validateRequired = (value: any): boolean => {\n  return value !== null && value !== undefined && value !== '';\n};\n\nexport const validateLength = (value: string, min: number, max: number): boolean => {\n  return value.length >= min && value.length <= max;\n};\n\n// Export the main validator\nexport default FormValidator;